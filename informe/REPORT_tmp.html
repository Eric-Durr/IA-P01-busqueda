<!DOCTYPE html>
<html>
<head>
<title>REPORT.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<div style="text-align: justify">
<br>
</div><span>
</span><p><img src="file:///mnt/c/Users/COCOS/Documents/IA/P01-Busqueda/informe/image/marca-universidad-de-la-laguna-original.png" alt="logo de la ull">
<span></p>
<br>
<br>
<div style="text-align: center">
</div><h1 id="estrategias-de-b%C3%BAsqueda--informe">Estrategias de búsqueda | Informe</h1>
<br>
<p>Inteligencia Artificial - ESIT (Escuela superior de Ingeniería y Tecnología) ULL</p>

<hr>
<br>
<br>
<br>
<br>
<p><img src="file:///mnt/c/Users/COCOS/Documents/IA/P01-Busqueda/informe/image/portada.jpg" alt="IA front image" title="image author: @upklyak, source: freepik"></p>
<br>
<br>
<br>
<br>
<pre><code>Informe desarrollado por Éric Dürr Sierra y Elena Rijo García

                        (alu0101027005)      (alu0101265421)
</code></pre>
<br>
<br>
<br>
<br>
<!-- end of cover page --->
<p>En este documento se van a exponer los aspectos relacionados a la práctica de estrategias de búsqueda. El contenido consta de una exposición de la
implementación, las pruebas y conclusiones para el algoritmo implementado y
una breve explicación sobre las metodologías empleadas.</p>
<br>
<hr>
<br>
<br>
<br>
<h2 id="%C3%ADndice-p%C3%A1gina"><strong>Índice</strong>                          Página:</h2>
<h2 id="1-introducci%C3%B3n">1. <a href="#id1">Introducción</a></h2>
<h2 id="2-entrorno-de-simulaci%C3%B3n-y-programaci%C3%B3n">2. <a href="#id2">Entrorno de simulación y programación</a></h2>
<h2 id="3-metodolog%C3%ADa-de-trabajo">3. <a href="#id3">Metodología de trabajo</a></h2>
<h2 id="4-algoritmos-de-b%C3%BAsqueda">4. <a href="#id4">Algoritmos de búsqueda</a></h2>
<h2 id="5-evaluaci%C3%B3n-experimental-del-algoritmo">5. <a href="#id5">Evaluación experimental del algoritmo</a></h2>
<h2 id="6-conclusiones">6. <a href="#id6">Conclusiones</a></h2>
<h2 id="7-referencias">7. <a href="#id7">Referencias</a></h2>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<hr>
<!-- end of index page --->
<br>
<br>
<br>
<br>
<br>
<br>
<div id="id1">
<br>
<br>
</div><h2 id="1-introducci%C3%B3n"><strong>1. Introducción.</strong></h2>
<br>
<br>
<h3 id="11-breve-descripci%C3%B3n-del-problema">1.1. Breve descripción del problema</h3>
<p>Nos encontramos ante un problema de estrategias de búsqueda para la resolución de la trayectoria mas óptima para un coche autónomo.</p>
<p>Contamos con un entorno dimensionado en MxN, en el cual nuestro coche va a efectuar sus movimientos, hacia sus casillas vecinas(Norte, Sur, Este y Oeste). Este entorno esta compuesto por celdas libres y celdas ocupadas, donde las celdas ocupadas podrán estar constituidas por un coche, una meta o varios obstáculos.</p>
<p>Nuestro coche, desde un punto inicial, deberá encontrar el camino mas óptimo teniendo en cuentas los diferentes entornos y obstáculos que se le pueden presentar para llegar hasta el punto de finalización (meta).</p>
<br>
<br>
<h3 id="12-formulaci%C3%B3n-del-problema-como-espacio-estados">1.2. Formulación del problema como espacio estados</h3>
<p>Hablaremos sobre el espacio de estados. Este se compondrá por un estado inicial, en el cual en su entorno tendrá el coche y la meta en la posición indicada por el usuario, además de definir dónde y cuántos obstáculos habría. También un estado final, en donde el coche llegaría a la posición de la meta.</p>
<p>Los estados y sus operadores, dependerán tanto del número y de dónde se encuentren los obstáculos como de la posición de la meta y del coche. Además, tenemos que tener en cuenta que cada movimiento del coche se va a ver influido por el estado de la casilla, ya que si hay casillas ocupadas, este no se podría mover hacia ella, reduciendo así el número posible de pasos.</p>
<br>
<br>
<div id="id2">
<br>
<br>
</div><h2 id="2-entorno-de-simulaci%C3%B3n-y-programaci%C3%B3n"><strong>2. Entorno de simulación y programación.</strong></h2>
<br>
<br>
<div id="id2d1">
</div><h3 id="21-descripci%C3%B3n-de-la-interfaz">2.1. Descripción de la interfaz.</h3>
<br>
<br>
<p>Hemos querido elegir C++ como lenguaje de desarrollo de simulación de esta práctica, ya que es un lenguaje que dominamos y hemos ido aprendiendo a lo largo de los cursos académicos. Nos beneficiamos de las ventajas que nos brinda la programación orientada a objetos, así como su modularidad.</p>
<p>La visualización y simulación del entorno y sus elementos se ha realizado a través de terminal, gracias a un menú con diversas opciones para un fácil manejo para el usuario. Este menú da las opciones de introducir manualmente los datos, teniendo en cuenta la inserción de los obstáculos de manera manual o aleatoria, y la posibilidad de cargar un fichero con los datos introducidos en este. Los datos pedidos al usuarios serán el tamaño MxN del entorno, la posición (i,j) del coche, de la meta, y de los obstáculos, poniendo especial atención en que si se elige la opción aleatoria los obstáculos se generaran en posiciones arbitrarias, excluyendo la posición del coche y de la meta.</p>
<p>También, en terminal, se visualiza la elección de la función heurística deseada, ya sea la función heurística Euclidea o la Manhattan.</p>
<p>Una vez se haya finalizado la inserción de todos los datos esperados, se generará visualmente nuestro entorno. De primera mano, se visualiza la posición del coche, la meta y los obstáculos, en las posiciones deseadas. Seguidamente, se vuelve a reflejar dicho entorno, pero esta vez mostrando mediante flechas el camino óptimo elegido para llegar al estado final.</p>
<p>Por último, podemos destacar que cada vez que termine la ejecución del programa, se limpiará la terminal y se lanzará de nuevo el menú por si el usuario desea volver a realizar el programa desde el principio, teníendo también la opción de salir de este.</p>
<p><img src="file:///mnt/c/Users/COCOS/Documents/IA/P01-Busqueda/informe/image/running_example.png" alt="Ejemplo de ejecucioón del programa"></p>
<br>
<br>
<h3 id="22-descripci%C3%B3n-de-la-implementaci%C3%B3n">2.2. Descripción de la implementación.</h3>
<br>
<br>
<p>Para la construcción de los elementos de la implementación se ha optado por
emplear un paradigma OOP (Object Oriented Programming) de modo que se distingan
los objetos clave del entorno y que cada uno almacene y contenga la
funcionalidad que se espera del mismo.</p>
<p>Los objetos que se emplean se pueden resumir como:</p>
<pre class="hljs"><code><div>  [Búsqueda] -&gt; Sirve para contener el entorno donde se halla el coche autónomo y 
                las estructuras de datos que permiten implementar el algoritmo
  
  [Entorno] -&gt; Construye una matriz de casillas que representan ubicaciones, además
               esta clase aporta datos como el punto de origen, el punto de destino
               y los valores heurísticos que se han obtenido del mismo.
  
  [Casilla] -&gt; Representa el estado, la ubicación y la relación respecto a otros 
               elementos del entorno. Principalmente se emplea para ubicar el coche,
               obstáculos y demás estados.
  
  [Coche]   -&gt; Es un objeto ideado para expresar su propio movimiento el entorno 
               actualizándose simultáneamente a las operaciones que se hacen en 
               el mismo. Además es el contenedor del sensor que detecta que 
               ubicaciones son posibles. 

</div></code></pre>
<p>Un entorno se compone por casillas, que a su vez, cualquiera de ellas puede
contener un objeto coche. Por otro lado el objeto de búsqueda, que es el que
contiene la implementación del algoritmo, contendra atributos que expresen el
entorno que manipula, las listas de datos para la implementación del algoritmo
y casillas destacables como el inicio o el fin de la búsqueda.</p>
<br>
<br>
<p><strong>Clase coche (SmartCar)</strong></p>
<p>Su implementación es sencilla se compone por unos atributos que permiten definir su posición en el tablero y un vector de booleanos que representan las lecturas del sensor para los puntos cardinales.</p>
<p>El método más destacable de entre los implementados es &quot;check_environment()&quot; que
permite hacer una lectura del entorno pasado por argumento y actualizar el sensor
en base a la ubicación actual y los elementos encontrados en el entorno.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SmartCar::check_environment</span><span class="hljs-params">(Environment&amp; env)</span> </span>{
  <span class="hljs-keyword">if</span> (env.pos(loc_i_ - <span class="hljs-number">1</span>, loc_j_) == <span class="hljs-number">-1</span>) {
    sensor_[N] = <span class="hljs-literal">true</span>;
  } <span class="hljs-keyword">else</span> {
    sensor_[N] = env.at(loc_i_ - <span class="hljs-number">1</span>, loc_j_).is_obs();
  }
  <span class="hljs-keyword">if</span> (env.pos(loc_i_ + <span class="hljs-number">1</span>, loc_j_) == <span class="hljs-number">-1</span>) {
    sensor_[S] = <span class="hljs-literal">true</span>;
  } <span class="hljs-keyword">else</span> {
    sensor_[S] = env.at(loc_i_ + <span class="hljs-number">1</span>, loc_j_).is_obs();
  }

  <span class="hljs-keyword">if</span> (env.pos(loc_i_, loc_j_ + <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>) {
    sensor_[E] = <span class="hljs-literal">true</span>;
  } <span class="hljs-keyword">else</span> {
    sensor_[E] = env.at(loc_i_, loc_j_ + <span class="hljs-number">1</span>).is_obs();
  }

  <span class="hljs-keyword">if</span> (env.pos(loc_i_, loc_j_ - <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>) {
    sensor_[W] = <span class="hljs-literal">true</span>;
  } <span class="hljs-keyword">else</span> {
    sensor_[W] = env.at(loc_i_, loc_j_ - <span class="hljs-number">1</span>).is_obs();
  }
}
</div></code></pre>
<p>El resto de métodos sirven para solicitar datos del objeto.</p>
<br>
<br>
<p><strong>Clase casilla (Slot)</strong></p>
<p>Se podría comparar su implementación a la de un nodo de cualquier SLL
donde se puede conocer el contenido, la ubicación actual y su nodo predecesor.
Sin embargo esta clase presenta algunas particularidades que personalizan su aplicación para el caso concreto.</p>
<p>En ella se definen algunas constantes que serán útiles para la impresión
de los roles que pueden interpretar estas casillas. También se define un enum
de cara a identificar y transformar estos objetos de una manera más natural y
semántica que mediante números.</p>
<pre class="hljs"><code><div>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> OBST_CHR <span class="hljs-meta-string">" ■ "</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VOID_CHR <span class="hljs-meta-string">" · "</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CAR__CHR <span class="hljs-meta-string">" © "</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GOAL_CHR <span class="hljs-meta-string">" X "</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> U_PATH_CHR <span class="hljs-meta-string">" ↑ "</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> R_PATH_CHR <span class="hljs-meta-string">" → "</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> D_PATH_CHR <span class="hljs-meta-string">" ↓ "</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> L_PATH_CHR <span class="hljs-meta-string">" ← "</span></span>

<span class="hljs-keyword">enum</span> <span class="hljs-keyword">slot_t</span> { V, O, C, G, U, R, D, L };

</div></code></pre>
<p>Debido a que se está trabajando con algoritmos de búsqueda esta clase tiene unas
componentes para facilitar el cálculo durante el algoritmo, cada casilla podrá almacenar y actualizar sus respectivos valores (g) y (f). En este objeto también
se sobrecarga el operador de igualdad que permitirá comparar nodos durante el
algoritmo.</p>
<br>
<br>
<p><strong>Clase entorno (Environment)</strong></p>
<p>Esta implementación simula una matriz en un vector de la STL, este contendrá
objetos de tipo casilla (Slot). Para simular la matriz se calcula la ubicación
dentro del vector en términos de <em>i</em> y <em>j</em>, el método &quot;pos(i, j)&quot; permitirá hacer
esta transformación</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Environment::pos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> <span class="hljs-keyword">const</span> </span>{
  <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; m_ &amp;&amp; j &lt; n_) {
    <span class="hljs-keyword">return</span> (i)*n_ + j;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
  }
}
</div></code></pre>
<p>Nótese que se verifica que una posición corresponda a un rángo adecuado, al
controlar esto podremos identificar como obstáculos (devolviendo -1) aquellas
posiciones que pudieran ser paredes.</p>
<p>Esta clase es destacable también por manejar todo lo relativo a las casillas que
contiene, ya sea estableciendo el estado de cada una de ellas o moviendo el coche
en un determinado sentido.</p>
<p>Es aquí donde se han implementado las funciones heurísticas ya que aportan datos
relativos al entorno. Las dos funciones heurísticas implementadas son la Manhattan
y la Euclídea. Su explicación y justificación se desarrollará más abajo en el
apartado <a href="#id4d3">4.3</a>. Se implementan 3 opciones para cada una de ellas donde se
puede optar por:</p>
<ul>
<li>Identificar su valor desde el inicio hasta la meta</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Environment::lineal_d</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">pow</span>(get_goal().pos_j() - get_car().pos()[<span class="hljs-number">1</span>], <span class="hljs-number">2</span>) +
              <span class="hljs-built_in">pow</span>(get_goal().pos_i() - get_car().pos()[<span class="hljs-number">0</span>], <span class="hljs-number">2</span>));
}

<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Environment::manhattan_d</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">return</span> (<span class="hljs-built_in">abs</span>(get_goal().pos_i() - get_car().pos()[<span class="hljs-number">0</span>]) +
          <span class="hljs-built_in">abs</span>(get_goal().pos_j() - get_car().pos()[<span class="hljs-number">1</span>]));
}
</div></code></pre>
<ul>
<li>Calcular desde cualquier nodo al nodo destino</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Environment::lineal_d</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Slot&amp; begin)</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">pow</span>(get_goal().pos_j() - begin.pos_j(), <span class="hljs-number">2</span>) +
              <span class="hljs-built_in">pow</span>(get_goal().pos_i() - begin.pos_i(), <span class="hljs-number">2</span>));
}

<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Environment::manhattan_d</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Slot&amp; begin)</span> </span>{
  <span class="hljs-keyword">return</span> (<span class="hljs-built_in">abs</span>(get_goal().pos_i() - begin.pos_i()) +
          <span class="hljs-built_in">abs</span>(get_goal().pos_j() - begin.pos_j()));
}
</div></code></pre>
<ul>
<li>Calcular entre dos ubicaciones cualesquiera</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Environment::lineal_d</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Slot&amp; begin, <span class="hljs-keyword">const</span> Slot&amp; end)</span> </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">pow</span>(end.pos_j() - begin.pos_j(), <span class="hljs-number">2</span>) +
              <span class="hljs-built_in">pow</span>(end.pos_i() - begin.pos_i(), <span class="hljs-number">2</span>));
}

<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Environment::manhattan_d</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Slot&amp; begin, <span class="hljs-keyword">const</span> Slot&amp; end)</span> </span>{
  <span class="hljs-keyword">return</span> (<span class="hljs-built_in">abs</span>(end.pos_i() - begin.pos_i()) + <span class="hljs-built_in">abs</span>(end.pos_j() - begin.pos_j()));
}
</div></code></pre>
<div id="rand">
</div><p>También se implementa para los objetos de tipo entorno un método que permita la
generación aleatoria de obstáculos dentro de la misma dado un porcentaje de volumen.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Environment::random_obs</span><span class="hljs-params">(<span class="hljs-keyword">float</span> ratio)</span> </span>{
  srand(time(<span class="hljs-literal">NULL</span>));
  <span class="hljs-keyword">int</span> r_obs = ratio * n_ * m_;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; r_obs; i++) {
    <span class="hljs-keyword">int</span> r_m = rand() % m_;
    <span class="hljs-keyword">int</span> r_n = rand() % n_;
    <span class="hljs-keyword">if</span> ((at(r_n, r_m).s_type() != C) &amp;&amp; (at(r_n, r_m).s_type() != G)) {
      set_obs(r_n, r_m);
    }
  }
}
</div></code></pre>
<p>Tal y como se aprecia lo que hace es, dentro de los límites, establecer tantos
objetos como el ratio lo permita en posiciones aleatorias  que se computan en base
a los límites del objeto.</p>
<p>La impresión del entorno también se define aquí, en este y en las clases que contiene
se sobrecarga el operador de salida estandar &quot;&lt;&lt;&quot; para que al imprimir el objeto
se visualice por consola o hacia donde sea direccionada la salida todos los
elementos del entorno.</p>
<pre class="hljs"><code><div><span class="hljs-built_in">std</span>::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">std</span>::ostream&amp; os, Environment&amp; obj) {
  os &lt;&lt; <span class="hljs-string">"┌"</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; obj.n_; i++) os &lt;&lt; <span class="hljs-string">"───"</span>;
  os &lt;&lt; <span class="hljs-string">"┐\n"</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; obj.m_; i++) {
    os &lt;&lt; <span class="hljs-string">"│"</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; obj.n_; j++) {
      os &lt;&lt; obj.at(i, j);
    }
    os &lt;&lt; <span class="hljs-string">"│"</span> &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">"\n"</span>;
  }

  os &lt;&lt; <span class="hljs-string">"└"</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; obj.n_; i++) os &lt;&lt; <span class="hljs-string">"───"</span>;
  os &lt;&lt; <span class="hljs-string">"┘\n\n"</span>;

  <span class="hljs-keyword">return</span> os;
}
</div></code></pre>
<p>Los bordes se imprimen usando caracteres especiales en base a los límites del
propio entorno, luego su contenido dependerá de lo que exprese cada casilla
individualmente, las casillas son por defecto vacío.</p>
<p>Un ejemplo de la impresión es el siguiente:</p>
<pre class="hljs"><code><div>┌─────────────────────────────────────────────┐
│ ©  ■  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  · │1
│ ↓  ■  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  · │2
│ ↓  →  ■  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  · │3
│ ·  ↓  →  ■  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  · │4
│ ·  ·  ↓  →  →  →  →  →  →  →  →  →  →  →  → │5
│ ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ↓ │6
│ ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ↓ │7
│ ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ↓ │8
│ ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ↓ │9
│ ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ↓ │10
│ ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ↓ │11
│ ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ↓ │12
│ ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ↓ │13
│ ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ↓ │14
│ ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  ·  X │15
└─────────────────────────────────────────────┘
</div></code></pre>
<p>Los números podrán permitir la pronta identificación de cada fila, no se incluyen en
horizontal para controlar el tamaño del propio tablero mejor, igualmente es fácil
identificar cada casilla mediante su punto o su elemento.</p>
<p>El camino se imprime con casillas que representan ese estado con una flecha que
indica el movimiento anteriormente realizado.</p>
<br>
<br>
<p><strong>Clase de búsqueda (Search)</strong></p>
<p>Esta clase incorpora el resto de elementos antes mencionados para centralizar la
operatividad del programa y así simplificar el programa principal.</p>
<p>Esta clase emplea múltiples métodos, los cuales serán explicados con un mayor
detenimiento ya que es donde se ubica el núcleo de la implementación del
propósito principal del algoritmo.</p>
<p>Para ser construida se requiere que un entorno ya haya sido definido previamente
incluyendo la ubicación del inicio, el destino y cada uno de los obstáculos que, contiene, en base a esto y a un modo de resolución indicado en el propio constructor
se definirá la implementación del algoritmo con una de las funciones heurísticas.</p>
<p>Esta función heurística será devuelta en base a esa elección por el método
&quot;heuristic_function(casilla)&quot; que devolverá el valor adecuado respecto a la
casilla indicada.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Search::heuristic_function</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Slot&amp; valor)</span> </span>{
  <span class="hljs-keyword">switch</span> (opcion_) {
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
      <span class="hljs-keyword">return</span> env_.lineal_d(valor);
      <span class="hljs-keyword">break</span>;

    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
      <span class="hljs-keyword">return</span> env_.manhattan_d(valor);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;
  }
}
</div></code></pre>
<blockquote>
<p>NOTA: Se ha usado un switch de cara a que en un futuro se pudieran añadir más
funciones heurísticas.</p>
</blockquote>
<br>
<p>Se implementan múltiples métodos accesores y de obtención de estados de los
elementos de la clase que serán útiles durante el cálculo del algoritmo:</p>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">o_list_empty</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>; <span class="hljs-comment">/* comprobar si la lista abierta está vacía */</span>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">c_list_empty</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>; <span class="hljs-comment">/* comprobar si la lista cerrada está vacía */</span>

  <span class="hljs-comment">/* Devuelve las posiciones i y j  de unos Slot específicos */</span>
  <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">get_start_pos</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>; 
  <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">get_car_pos</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;
  <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">get_goal_pos</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;


  <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">path_to_string</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>; <span class="hljs-comment">/* Imprime el camino óptimo como una cadena*/</span>
  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">path_size</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>; <span class="hljs-comment">/* Devuelve el tamaño del camin óptimo*/</span>

</div></code></pre>
<p>Poir último el algoritmo de búsqueda, que es el A-Estrella será explicado en
mayor detalle en los apartados <a href="#id4d1">4.1</a> y <a href="#id4d2">4.2</a>.</p>
<p>El algoritmo se sirve de la funcionalidad de unos cuantos métodos:</p>
<ul>
<li>
<p>is_in_open(Slot) : Permite saber si una casilla está en la lista abierta</p>
</li>
<li>
<p>is_in_close(Slot) : Permite saber si una casilla está en la lista cerrada</p>
</li>
<li>
<p>trace_path(Slot) : una vez hallado el final se dibuja el camino de salida</p>
<p>(de no hallarse se opta por no imprimir nada y se notifica mediante un mensaje el éxito o el fracaso de la búsqueda)</p>
</li>
</ul>
<br>
<br>
<p><strong>Programa principal &quot;Smart lookup&quot;</strong></p>
<p>El programa principal tiene dos modos de uso</p>
<br>
<p><strong>Modo mediante linea de comandos</strong></p>
<p>Para un acceso más rápido se ha hecho una lectura de la línea de comandos de manera que si se quisiera lanzar el programa mediante la lectura de un fichero que describa el entorno o directamente ejecutar una versión aleatoria del programa basta con
ejecutar el programa con las opciones adecuadas</p>
<ul>
<li><code>./smart_lookup -f fichero_de_entrada.txt</code></li>
<li><code>./smart_lookup -r</code></li>
</ul>
<p>Esta lectura se ha hecho mediante la función &quot;getopt()&quot; construida en C++.</p>
<br>
<p><strong>Modo por defecto (menú)</strong></p>
<p>Sin embargo si se hiciera una ejecución sin argumentos del programa se entraría
en un menú de opciones que irá guiando al usuario, estos aspectos ya han sido
descritos en el apartado <a href="#id2d1">2.1</a>.</p>
<p>La implementación de este programa principal trata de refactorizar, en la medida
de lo posible, el máximo número de funcionalidades en subrutinas que serán invocadas
durante la ejecución. De esta manera la totalidad de la función principal
está compuesta por el bucle while del menú (sin contar la lectura de comandos).
Este bucle termina cuando el usuario lo indica y siempre que se lanza una opción
se limpia la terminal.</p>
<pre class="hljs"><code><div> <span class="hljs-keyword">while</span> (op != <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\n\n --- Smart lookup with a-star algorithm menú ---\n"</span>;
      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"1) Manual environment creator\n"</span>;
      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"2) Semi-random environment creator\n"</span>;
      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"3) File readed environment creator\n"</span>;
      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"0) Exit program\n\n"</span>;
      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"&gt; "</span>;
      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; op;
      <span class="hljs-keyword">switch</span> (op) {
        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
          manual_env();
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
          random_env();
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Type a valid filename: "</span>;
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; filename;
          file_env(filename);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">default</span>:
          <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Option not suported\n"</span>;
          <span class="hljs-keyword">break</span>;
      }
      <span class="hljs-keyword">if</span> (op != <span class="hljs-number">0</span>) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Press ENTER to continue: \n"</span>;
        <span class="hljs-built_in">std</span>::getchar();
        <span class="hljs-built_in">std</span>::getchar();
      }
      system(<span class="hljs-string">"clear"</span>);
    }
  }
</div></code></pre>
<p>Tal y como se puede apreciar cada una de las funcionalidades se encapsulan en funciónes que se invocan según lo desea el usuario quedando de esta manera un código
más sencillo de leer y más sintetizado. Durante la ejecución se ve de la siguiente manera:</p>
<p><img src="file:///mnt/c/Users/COCOS/Documents/IA/P01-Busqueda/informe/image/menu_launch.png" alt="Ejemplo de ejecución del programa principal - menú de selección"></p>
<p>Dado que las subrutinas funcionan todas de manera similar analizaremos en detalle
una sola de ellas, en concreto la creación manual del entorno por ser más completa.</p>
<p>En esta subrutina el primer paso consiste en establecer los valores básicos
para constituir el entorno, para ello se le solicita su inserción al usuario por
linea de comandos.</p>
<p>a la hora de solicitar las posiciones de inicio, fin u obstáculos se verifica
que los valores introducidos están dentro del rango esperado, en caso contrario se notifica y se vuelve a solicitar el valor</p>
<pre class="hljs"><code><div><span class="hljs-keyword">while</span> (inrange == <span class="hljs-literal">false</span>) {
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Now introduce the start position (Example: 1 1): "</span>;
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; st_pos_i &gt;&gt; st_pos_j;
  <span class="hljs-keyword">if</span> (man_env.pos(st_pos_i - <span class="hljs-number">1</span>, st_pos_j - <span class="hljs-number">1</span>) != <span class="hljs-number">-1</span>) {
    inrange = <span class="hljs-literal">true</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\nERROR: Make sure that the numbers are between 1 and the "</span>
                 <span class="hljs-string">"limits\n"</span>
              &lt;&lt; <span class="hljs-string">"try again\n\n"</span>;
  }
}
</div></code></pre>
<p>Un bucle while controlado por una variable de estado nos permitirá realizar esto de manera cómoda. Se hace uso de la función pos del entorno para comprobar que esté
en el rango, ya que esta devolverá -1 en caso de errar, haciendo más simple el condicional.</p>
<p>Una vez superado el bucle se reestablece el valor de inrange a falso para su posterior uso.</p>
<blockquote>
<p>Nótese que se espera que los números a introducir se expresen en términos de [1 - N] ya que este tipo de rangos suele ser más intuitivo para todo el mundo.</p>
</blockquote>
<p>La creación de obstáculos en este modo es opcional, por ello se pregunta primero al usuario y , en caso afirmativo, se lanza el método para la introducción uno a uno
de los obstáculos.</p>
<pre class="hljs"><code><div><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Do you want to introduce some obstacles? (yes/no): "</span>;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; obs_bool;
<span class="hljs-keyword">if</span> (obs_bool[<span class="hljs-number">0</span>] == <span class="hljs-string">'Y'</span> || obs_bool[<span class="hljs-number">0</span>] == <span class="hljs-string">'y'</span>) {
    introduce_obstacles(man_env);
}
</div></code></pre>
<p>Sigue la misma metodología para detectar posiciones correctas y cada obstáculo
es solicitado e introducido hasta que se decide parar de introducir.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Set an obstacle as done with the start or goal point "</span>
               <span class="hljs-string">"(Example: 2 2): "</span>;
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; obs_i_pos &gt;&gt; obs_j_pos;

  <span class="hljs-keyword">if</span> (man_env.pos(obs_i_pos - <span class="hljs-number">1</span>, obs_j_pos - <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>) {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\nERROR: Make sure that the numbers are between 1 and "</span>
                 <span class="hljs-string">"the limits\n"</span>
              &lt;&lt; <span class="hljs-string">"try again\n\n"</span>;
  } <span class="hljs-keyword">else</span> {
    man_env.set_obs(obs_i_pos - <span class="hljs-number">1</span>, obs_j_pos - <span class="hljs-number">1</span>);
  }
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Do you want to stop adding obstacles? (yes/no): "</span>;
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cin</span> &gt;&gt; continuer;
  <span class="hljs-keyword">if</span> (continuer[<span class="hljs-number">0</span>] == <span class="hljs-string">'Y'</span> || continuer[<span class="hljs-number">0</span>] == <span class="hljs-string">'y'</span>) {
    <span class="hljs-keyword">return</span>;
  }
}
</div></code></pre>
<p>El paso siguiente a la consitución de obstáculos es la selección del valor heurístico
donde se da a elegir entre las opciones disponibles, el usuario debe elegir
introduciendo por teclado, la opción que desea.</p>
<p>Una vez elegida se crea el objeto de búsqueda pasándole el entorno y la opción
heurística como argumentos. A continuación de esto se lanza el algoritmo de búsqueda.</p>
<pre class="hljs"><code><div><span class="hljs-function">Search <span class="hljs-title">man_env_search</span><span class="hljs-params">(man_env, h_op)</span></span>;
man_env_search.a_star_algorithm();
</div></code></pre>
<p>Para finalizar se imprime el camino de resultado por salida estandar y en caso
de que las dimensiones sean mayor de 100x100 esta salida se redirige a un fichero
de texto.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (row_sz &gt;= <span class="hljs-number">100</span> || col_sz &gt;= <span class="hljs-number">100</span>) {
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Output file generated because of the size\n"</span>;
  <span class="hljs-function"><span class="hljs-built_in">std</span>::ofstream <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-string">"man_result.txt"</span>)</span></span>;
  output &lt;&lt; man_env_search &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
  output.close();
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; man_env_search &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
}
</div></code></pre>
<p>Tal y como se ha mencionado las otras subrutinas son similares pero con algunos aspectos particulares.</p>
<p>Para la creación aleatoria del entorno los obstáculos son generados introduciendo
una opción de ratio de obstáculos y llamando al método ya descrito <a href="#rand">random_obs()</a>. El resto de la implementación es similar a la opción manual.</p>
<br>
<br>
<h3 id="23-argumentaci%C3%B3n-sobre-el-entorno-de-programaci%C3%B3n-escogido">2.3. Argumentación sobre el entorno de programación escogido.</h3>
<p>Se ha escogido un entorno basado en el lenguaje C++ por diversos motivos. Fundamentalmente la comodidad de usar un lenguaje ya conocido y en el que ambos
componentes pueden manejarse de manera independiente.</p>
<p>Un punto muy positivo que ayudó a la elección del lenguaje es la amplia comunidad y volumen de documentación del que dispone. Esto ha facilitado en gran medida el desarrollo del proytecto. También ha influido en la posibilidad de implementar técnicas de desarrollo como TDD o BDD mediante librerías que la comunidad ha desarrollado de manera opensource como es <em><strong>Catch2</strong></em>.</p>
<p>También es bastante similar a muchos lenguajes por lo que muchas personas que quisieran acceder al proyecto podrían entender muchos de los aspectos que lo componen</p>
<p>Por sus características C++ es un lenguaje que tiene mucha potencia de cómputo y, para el caso que nos ocupa, resulta muy útil. Se obtendrán resultados a mayor velocidad que con muchos otros lenguajes.</p>
<p>Por otro lado y entrando en aspectos más generales se ha optado por un entorno de
programación basado en directorios que separan cabeceras, código de desarrollo y tests, de manera que un solo fichero Makefile pueda componer rápidamente muchos de los comandos más frecuentes para el proyecto.</p>
<p>El trabajo con Git como herramienta colaborativa requiere también de un espacio organizado y fuertemente modular de cara a evitar conflictos.</p>
<br>
<br>
<div id="id3">
<br>
<br>
</div><h2 id="3-metodolog%C3%ADa-de-trabajo"><strong>3. Metodología de trabajo.</strong></h2>
<br>
<br>
<h3 id="31-metodolog%C3%ADa-de-desarrollo">3.1. Metodología de desarrollo.</h3>
<!-- TDD -->
<p>Para este apartado, hemos decidido utilizar un desarrollo guiado por pruebas, también conocido como TDD (Test-driven development). Esta técnica consiste en escribir primero las pruebas de espectativas de código, seguidamente escribir el código fuente que queremos que pase la prueba satisfactoriamente, y por último, refactorizar el código escrito.</p>
<p>Gracias a esto, podemos agilizar nuestro proceso de creación de código, llevado a cabo la implementación de diversos test, que nos han servido para ir desarrollando dentro de cada clase, los métodos necesarios requeridos para esta práctica. Además, hemos evitado la creación de métodos innecesarios o de código que no se utiliza en nuestro programa, produciendo así un mayor robustez y mantenibilidad ante el problema.</p>
<p>Por otro lado, poder separar cada uno de los aspectos en diferentes fragmentos ejecutables permite la rápida y ágil detección de errores de funcionamiento, evitando tener que reescribir gran parte del código.</p>
<br>
<br>
<h3 id="32-metodolog%C3%ADa-de-colaboraci%C3%B3n-y-distribuci%C3%B3n-de-carga">3.2. Metodología de colaboración  y distribución de carga.</h3>
<p>Se ha intentado distribuir lo más equitativa y controladamente la carga de trabajo. Para cumplir ambas expectativas se ha optado por el usi de GitHub como plataforma principal para el acceso y control del trabajo colaborativo.</p>
<p>Principalmente la herramienta git permite el desarrollo asíncrono del trabajo en grupo, ya que haciendo uso de las ramas se puede separar el desarrollo del mismo fichero de texto evitando los solapamientos y conflictos que esto pudiera causar.</p>
<p>Empleando GitHub como plataforma podremos hacer uso de diversas funcionalidades colaborativ as que este aporta, como es el control de las ramas, las estadísticas de aportación de trabajo -- que bien podrían ser empleadas para reorganizar el volumen de trabajo -- y la herramienta tipo kanban (GitHub Projects) que permite definir y asignar una serie de tareas, además de controlar aquellas que ya están finalizadas.</p>
<p><img src="file:///mnt/c/Users/COCOS/Documents/IA/P01-Busqueda/informe/image/gh_projects.png" alt="Ejemplo de Projects de GitHub del informe"></p>
<p>Por otro lado Git ha permitido ir añadiendo funcionalidades y código de manera paulatina, cosa que junto al TDD comentado en el apartado anterior reduce en gran medida el tiempo de desarrollo y, por ende, la cantidad de errores.</p>
<p>Como conclusión de este apartado el volumen de trabajo de ambos queda algo difuso, ya que no se ha asignado una tarea concreta a cada componente salvo la elaboración de los puntos del informe. En cuanto al desarrollo la distribución de código se ha hecho lo más paralela posible y repartida de modo que ambos componentes puedan conocer bien la implementación.</p>
<br>
<br>
<div id="id4">
<br>
<br>
</div><h2 id="4-algoritmo-de-b%C3%BAsqueda"><strong>4. Algoritmo de búsqueda.</strong></h2>
<br>
<br>
<div id="id4d1">
</div><h3 id="41-pseudo-c%C3%B3digo">4.1. Pseudo-código.</h3>
<pre><code>ALGORITMO DE BÚSQUEDA A-ESTRELLA

  nodo_inicial.valor_f = 0
  insertar nodo inicial en lista abierta 

  MIENTRAS (lista abierta no vacía)

    q = nodo mínimo de lista abierta
    borrar q de lista abierta
    insertar q en lista cerrada

    generar sucesores de q

    PARA (cada sucesor)

      SI (es el destino)

        sucesor_padre = q
        sucesor.valor_g = q.valor_g + unidad_de_coste
        sucesor.valor_f = sucesor.valor_g + función_heurística(sucesor)
        generar camino
        SALIR DE LA BÚSQUEDA
      __

      EN OTRO CASO SI (no está en la lista cerrada y no es obstáculo)
        g = q.valor_g + unidad_de_coste;
        f = funcion_heurística(sucesor)
        SI (no está en la lista abierta)
          actualizar padres en el entorno
          sucesor_padre = q
          sucesor.valor_g = g
          sucesor.valor_f = f
          insertar sucesor en lista abierta
        __
      __
    __ 
  __

  SALIR DE LA BÚSQUEDA
__
</code></pre>
<p>La implementación del pseudocósigo implementado se traduce directamente a C++
destacando algunos aspectos esenciales</p>
<ol>
<li>Se emplea una variable para detectar si la meta ha sido encontrada, de este modo al llegar al final del algoritmo si no se ha encontrado se podrá notificar de ello:</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (found_goal == <span class="hljs-literal">false</span>) {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"VEHICLE CANT REACH THE GOAL\n "</span>;
}
</div></code></pre>
<ol start="2">
<li>Para hallar el valor mínimo se itera con un bucle automático habiendo establecido un valor previo para el nodo mínimo (en este caso el útlimo valor de la lista). Acto seguido se elimina ese nodo de la lista abierta haciendo uso de la STL y se inserta en la lista cerrada.</li>
</ol>
<pre class="hljs"><code><div>Slot min = open_.back();
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> current : open_)
  <span class="hljs-keyword">if</span> (min.get_f() &gt;= current.get_f()) {
    min = current;
}
open_.erase(<span class="hljs-built_in">std</span>::find(open_.begin(), open_.end(), min));
<span class="hljs-comment">/*  ---  */</span>

closed_.push_back(min);
</div></code></pre>
<ol start="3">
<li>Los sucesores se generan haciendo uso de un método privado, este emplea el entorno para localizar el nodo origen y componer un vector que contenga en orden los puntos cardinales que se consideran como sucesores. Dentro de este método si la posición no es accesible se sitúa en (-1, -1) y se establece su estado como obstáculo.</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Slot&gt; <span class="hljs-title">Search::get_successors</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Slot&amp; q)</span> </span>{
  Slot north = env_.pos(q.pos_i() - <span class="hljs-number">1</span>, q.pos_j()) != <span class="hljs-number">-1</span>
                   ? env_.at(q.pos_i() - <span class="hljs-number">1</span>, q.pos_j())
                   : Slot(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, O);
  ...
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Slot&gt;{north, ...};
}
</div></code></pre>
<ol start="4">
<li>Luego esta lista de casillas será iterada para escoger las no visitadas e introducirlas en la lista abierta con sus respectivos valores o localizar la meta. También se actualizan los estados que componen el camino.</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> var : successors) {
      <span class="hljs-keyword">if</span> (var.get_obs() == G) {
        env_.at(var.pos_i(), var.pos_j()).set_parents(min.pos_i(), min.pos_j());
        var.set_parents(min.pos_i(), min.pos_j());
        var.set_g(min.get_g() + MOVE_VAL); <span class="hljs-comment">/* 2nd arg is in doubt */</span>
        var.set_f(var.get_g() + heuristic_function(var)); <span class="hljs-comment">/* blocked h */</span>

        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\nGOAL FOUND !\n"</span>;
        trace_path(var);
        found_goal = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span>;

        <span class="hljs-comment">/* If it's not yet at close list and it´s not an obstacle */</span>
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((is_in_close(var) == <span class="hljs-literal">false</span>) &amp;&amp; (var.is_obs() == <span class="hljs-literal">false</span>)) {
        new_g = min.get_g() + MOVE_VAL;
        new_h = heuristic_function(var);
        new_f = new_g + new_h;

        <span class="hljs-comment">/* If it's not at open list or it is but with lower f, insert it */</span>
        <span class="hljs-keyword">if</span> (is_in_open(var) == <span class="hljs-literal">false</span>) {
          env_.at(var.pos_i(), var.pos_j())
              .set_parents(min.pos_i(), min.pos_j());
          var.set_parents(min.pos_i(), min.pos_j());
          var.set_g(new_g);
          var.set_f(new_f);

          open_.push_back(var);
        }
      }
    }
</div></code></pre>
<ol start="5">
<li>Cuando se alcanza la meta se llama a trace_path() para componer el camino. Este método va recorriendo los predecesores de cada casilla hasta llegar al origen, el resultado se guarda en un atributo. &quot;temp&quot; hace alusión al último nodo revisado, osea la meta.</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">while</span> (temp.parent_i() != <span class="hljs-number">-1</span> &amp;&amp; temp.parent_j() != <span class="hljs-number">-1</span>) {
    path_.push_back(temp);
    temp = env_.at(temp.parent_i(), temp.parent_j());
  }

</div></code></pre>
<br>
<br>
<div id="id4d2">
</div><h3 id="42-estructura-de-datos-empleada">4.2. Estructura de datos empleada.</h3>
<p>Se pueden distinguir tres estructuras de datos. Empezaremos por el propio entorno.</p>
<ol>
<li>El entorno que describe la ubicación de todas las casillas se  compone por un vector que simula una matriz, dentro de cada elemento del vector se halla cada casilla.</li>
</ol>
<pre class="hljs"><code><div>&lt;-------NxM-------&gt;   
[ | | | ... | | | ] 


      j0 j1 j2    jm        j0 j1 j2    jm             j0 j1 j2    jm
 [i0(|  |  | ... |  |), i1(|  |  | ... |  |), ..., in(|  |  | ... |  |)]
</div></code></pre>
<p>Se opera por completo dentro de este medio a la hora de localizar obstáculos, mover el coche y situar la meta. Su localización se describe en el apartado 2.2 junto a la descripción de la implementación del entorno.</p>
<ol start="2">
<li>
<p>Luego se distinguen las listas cerrada y abierta que nuevamente son vectores de casillas, sin embargo estas estructuras sencillamente son contenedores, no simulan una matriz como lo hace el entorno. También se emplea un vector denominado como &quot;path&quot; que contendrá, en orden, las casillas del camino óptimo.</p>
</li>
<li>
<p>Por último el  objeto casilla (Slot) sirve de nodo para almacenar cada elemento del entorno así como su posición y la de su predecesor.</p>
</li>
</ol>
<pre class="hljs"><code><div> (ELEMENTO DEL ENTORNO | POS_I ,POS_J | PADRE_I, PADRE_J)
</div></code></pre>
<br>
<br>
<div id="id4d3">
</div><h3 id="43-funciones-heur%C3%ADsticas-y-justificaci%C3%B3n">4.3. Funciones heurísticas y justificación.</h3>
<p>Las funciones heurísticas utilizadas han sido la Euclidea y la Manhattan. Hablaremos de ellas:</p>
<ul>
<li>
<p>Función heurística Euclidea:
Esta función aplica la fórmula matemática que nos permite medir la distancia en línea recta entre dos puntos en un espacio de n-dimensiones. En nuestro caso, esta función se realizará en línea recta entre la posición del coche y la posición de la meta, sin tener en cuenta los obstáculos definidos, por lo que se obtendrá el resultado de esta operación matemática. Este resultado nos será útil posteriormente, ya que será uno de los factores que utilizarémos para hallar el camino óptimo.</p>
</li>
<li>
<p>Función heurística Manhattan:
Esta función, de forma similar a la anterior, trata de una fórmula matemática que nos permite calcular la distancia entre dos puntos, esta vez haciendo uso de la suma absoluta de las distancias horizontal y vertical de las direncias de sus coordenadas. Es mayor que la distancia euclídea pero también es más real en la práctica. En nuestro caso, esta función se realizará entre la posición del coche y la posición de la meta, sin tener en cuenta los obstáculos definidos, por lo que se obtendrá el resultado de esta operación matemática. Este resultado nos será útil posteriormente, ya que será uno de los factores que utilizarémos para hallar el camino óptimo.</p>
</li>
</ul>
<br>
<br>
<div id="id5">
<br>
<br>
</div><h2 id="5-evaluaci%C3%B3n-experimental-del-algoritmo"><strong>5. Evaluación experimental del algoritmo.</strong></h2>
<br>
<br>
<br>
<br>
<h3 id="evaluaci%C3%B3n-de-las-tablas-sin-obst%C3%A1culos">Evaluación de las tablas sin obstáculos</h3>
<br>
<p>Escenario pequeño (50*50). Encontrándose el coche en la posición (1,1) y la meta en la (50,50)</p>
<table>
<thead>
<tr>
<th style="text-align:left">Funciones H</th>
<th style="text-align:center">Número de nodos expandidos</th>
<th style="text-align:center">Longitud del camino (pasos)</th>
<th style="text-align:right">tiempo (ms)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Euclidea</td>
<td style="text-align:center">2498</td>
<td style="text-align:center">98</td>
<td style="text-align:right">10451</td>
</tr>
<tr>
<td style="text-align:left">Manhattan</td>
<td style="text-align:center">193</td>
<td style="text-align:center">98</td>
<td style="text-align:right">40</td>
</tr>
</tbody>
</table>
<br>
<br>
<p>Escenario mediano (100*100). Encontrándose el coche en la posición (1,1) y la meta en la (100,100)</p>
<table>
<thead>
<tr>
<th style="text-align:left">Funciones H</th>
<th style="text-align:center">Número de nodos expandidos</th>
<th style="text-align:center">Longitud del camino (pasos)</th>
<th style="text-align:right">tiempo (ms)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Euclidea</td>
<td style="text-align:center">9998</td>
<td style="text-align:center">198</td>
<td style="text-align:right">175603</td>
</tr>
<tr>
<td style="text-align:left">Manhattan</td>
<td style="text-align:center">393</td>
<td style="text-align:center">198</td>
<td style="text-align:right">234</td>
</tr>
</tbody>
</table>
<br>
<br>
<p>Escenario grande (200*200). Encontrándose el coche en la posición (1,1) y la meta en la (200,200)</p>
<table>
<thead>
<tr>
<th style="text-align:left">Funciones H</th>
<th style="text-align:center">Número de nodos expandidos</th>
<th style="text-align:center">Longitud del camino (pasos)</th>
<th style="text-align:right">tiempo (ms)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Euclidea</td>
<td style="text-align:center">39998</td>
<td style="text-align:center">398</td>
<td style="text-align:right">2669206 (44 min)</td>
</tr>
<tr>
<td style="text-align:left">Manhattan</td>
<td style="text-align:center">793</td>
<td style="text-align:center">398</td>
<td style="text-align:right">1239</td>
</tr>
</tbody>
</table>
<br>
<br>
<br><br>
<h3 id="evaluaci%C3%B3n-de-las-tablas-25-obst%C3%A1culos">Evaluación de las tablas  25% obstáculos</h3>
<br>
<p>Escenario pequeño (50*50). Encontrándose el coche en la posición (1,1) y la meta en la (50,50)</p>
<table>
<thead>
<tr>
<th style="text-align:left">Funciones H</th>
<th style="text-align:center">Número de nodos expandidos</th>
<th style="text-align:center">Longitud del camino (pasos)</th>
<th style="text-align:right">tiempo (s)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Euclidea</td>
<td style="text-align:center">1702</td>
<td style="text-align:center">98</td>
<td style="text-align:right">5316</td>
</tr>
<tr>
<td style="text-align:left">Manhattan</td>
<td style="text-align:center">455</td>
<td style="text-align:center">98</td>
<td style="text-align:right">269</td>
</tr>
</tbody>
</table>
<br>
<br>
<p>Escenario mediano (100*100). Encontrándose el coche en la posición (1,1) y la meta en la (100,100)</p>
<table>
<thead>
<tr>
<th style="text-align:left">Funciones H</th>
<th style="text-align:center">Número de nodos expandidos</th>
<th style="text-align:center">Longitud del camino (pasos)</th>
<th style="text-align:right">tiempo (s)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Euclidea</td>
<td style="text-align:center">7111</td>
<td style="text-align:center">198</td>
<td style="text-align:right">88758</td>
</tr>
<tr>
<td style="text-align:left">Manhattan</td>
<td style="text-align:center">994</td>
<td style="text-align:center">198</td>
<td style="text-align:right">1379</td>
</tr>
</tbody>
</table>
<br>
<br>
<p>Escenario grande (200*200). Encontrándose el coche en la posición (1,1) y la meta en la (200,200)</p>
<table>
<thead>
<tr>
<th style="text-align:left">Funciones H</th>
<th style="text-align:center">Número de nodos expandidos</th>
<th style="text-align:center">Longitud del camino (pasos)</th>
<th style="text-align:right">tiempo (s)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Euclidea</td>
<td style="text-align:center">31100</td>
<td style="text-align:center">398</td>
<td style="text-align:right">1643390 (27 min)</td>
</tr>
<tr>
<td style="text-align:left">Manhattan</td>
<td style="text-align:center">5424</td>
<td style="text-align:center">398</td>
<td style="text-align:right">39364</td>
</tr>
</tbody>
</table>
<br>
<br>
<br><br>
<h3 id="evaluaci%C3%B3n-de-las-tablas-50-obst%C3%A1culos">Evaluación de las tablas 50% obstáculos</h3>
<br>
<p>Escenario pequeño (50*50). Encontrándose el coche en la posición (1,1) y la meta en la (50,50)</p>
<table>
<thead>
<tr>
<th style="text-align:left">Funciones H</th>
<th style="text-align:center">Número de nodos expandidos</th>
<th style="text-align:center">Longitud del camino (pasos)</th>
<th style="text-align:right">tiempo (s)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Euclidea</td>
<td style="text-align:center">3647</td>
<td style="text-align:center">126</td>
<td style="text-align:right">9132</td>
</tr>
<tr>
<td style="text-align:left">Manhattan</td>
<td style="text-align:center">4</td>
<td style="text-align:center">No encuentra la meta</td>
<td style="text-align:right">1</td>
</tr>
</tbody>
</table>
<br>
<br>
<p>Escenario mediano (100*100). Encontrándose el coche en la posición (1,1) y la meta en la (100,100)</p>
<table>
<thead>
<tr>
<th style="text-align:left">Funciones H</th>
<th style="text-align:center">Número de nodos expandidos</th>
<th style="text-align:center">Longitud del camino (pasos)</th>
<th style="text-align:right">tiempo (s)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Euclidea</td>
<td style="text-align:center">5</td>
<td style="text-align:center">no encuentra la meta</td>
<td style="text-align:right">1</td>
</tr>
<tr>
<td style="text-align:left">Manhattan</td>
<td style="text-align:center">2</td>
<td style="text-align:center">No encuentra la meta</td>
<td style="text-align:right">1</td>
</tr>
</tbody>
</table>
<br>
<br>
<p>Escenario grande (200*200). Encontrándose el coche en la posición (1,1) y la meta en la (200,200)</p>
<table>
<thead>
<tr>
<th style="text-align:left">Funciones H</th>
<th style="text-align:center">Número de nodos expandidos</th>
<th style="text-align:center">Longitud del camino (pasos)</th>
<th style="text-align:right">tiempo (s)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Euclidea</td>
<td style="text-align:center">145</td>
<td style="text-align:center">no encuentra la meta</td>
<td style="text-align:right">220</td>
</tr>
<tr>
<td style="text-align:left">Manhattan</td>
<td style="text-align:center">21</td>
<td style="text-align:center">no encuentra la meta</td>
<td style="text-align:right">28</td>
</tr>
</tbody>
</table>
<!-- Resultados empíricos -> la situación del coche influye en las probabilidades de encontrar meta, no es altamente improbable pero si mucho menos probable. -->
<br>
<br>
<br><br>
<h3 id="evaluaci%C3%B3n-de-las-tablas-80-obst%C3%A1culos">Evaluación de las tablas 80% obstáculos</h3>
<!-- No encuentra salida + nuevo intervalo de pruebas apto + referencia a conclusiones-->
<p><img src="file:///mnt/c/Users/COCOS/Documents/IA/P01-Busqueda/informe/image/random_options.png" alt="Nuevo intervalo extendido de volúmenes de obstáculos"></p>
<br>
<br>
<br><br>
<br>
<br>
<div id="id6">
<br>
<br>
</div><h2 id="6-conclusiones"><strong>6. Conclusiones.</strong></h2>
<br>
<br>
<!-- limite de tamaño a 50% por ser altamente improbable + intervalo de pruebas apto + manhattan > euclidea -->
<p>Tras todas las pruebas realizadas uno de los aspectos más notables es la
ineficiencia del algoritmo implementado al aplicar la función heurística
euclídea ya que expande la mayor cantidad de nodos posibles, se camufla un poco
esta ineficiencia cuando el entorno consta de muchos obstáculos, sin embargo en
todas las pruebas se ha visto superada por las pruebas que implican la función
heurística manhattan.</p>
<p>Por otro lado las pruebas del algoritmo también han servido para destacar algunas
limitaciones del programa:</p>
<ol>
<li>
<p>El máximo tamaño de entorno sin perder eficiencia ronda las 200 x 200 casillas,
es a partir de entonces cuando se nota un ralentizamiento en el cómputo del
camino óptimo.</p>
</li>
<li>
<p>Ante un volumen del 50% de obstáculos se vuelve altamente improbable hallar una
solución.</p>
</li>
</ol>
<p>Este último aspecto ha servido para establecer como límite superior un 50% de
obstáculos y, en base a ello, se ha establecido un rango más adecuado en el
programa para hacer pruebas con diversos porcentajes.</p>
<br>
<br>
<div id="id7">
<br>
<br>
</div><h2 id="7-referencias"><strong>7. Referencias.</strong></h2>
<!-- aportadas por eric -->
<ul>
<li>
<p><a href="https://www.geeksforgeeks.org/a-search-algorithm/">Implementación de algoritmo a-estrella | GeeksForGeeks</a></p>
<blockquote>
<p>Implementación en un solo fichero del algoritmo a-estrella en lenguaje c++.</p>
</blockquote>
</li>
<li>
<p><a href="https://www.geeksforgeeks.org/measure-execution-time-function-cpp/">Cálculo del tiempo de ejecución | GeeksForGeeks</a></p>
<blockquote></blockquote>
</li>
<li>
<p><a href="https://data-flair.training/blogs/advantages-and-disadvantages-of-cpp/">advantages and disadvantages of C++ | Data flair </a></p>
</li>
</ul>
<!-- Aportadas por Elena -->
<br>
<br>

</body>
</html>
